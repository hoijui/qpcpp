<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>QP/C++: 6. Defining Event Signals and Event Parameters</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">QP/C++
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="index.html">QP/C++ Reference Manual</a></li><li class="navelem"><a class="el" href="tutorial_page.html">QP/C++ Tutorial</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title"><ol type="1">
<li>Defining Event Signals and Event Parameters </li>
</ol>
</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><em>This QP/C++ Tutorial is adapted from Chapter 1 of <a class="el" href="index.html#PSiCC2">Practical UML Statecharts in C/C++, Second Edition</a><br/>
by Miro Samek, the founder and president of Quantum Leaps, LLC.</em></p>
<div class="image">
<img src="qp_tutorial.jpg" alt="qp_tutorial.jpg"/>
</div>
<p>Prev: <a class="el" href="active_objects.html"><ol type="1">
<li>Elaborating State Machines of Active Objects</li>
</ol>
</a> <br/>
Next: <a class="el" href="coding_hsm.html"><ol type="1">
<li>Coding Hierarchical State Machines</li>
</ol>
</a></p>
<p>The key events in the "Fly 'n' Shoot" game have been identified in the sequence diagram in <a class="el" href="design.html#F4s1">Figure 4-1</a>. Other events have been invented during the state machine design stage. In any case, you must have noticed that events consist really of two parts. The part of the event called the signal conveys the type of the occurrence (what happened). For example, the <code>TIME_TICK</code> signal conveys the arrival of a time tick, while <code>PLAYER_SHIP_MOVE</code> signal conveys that the player wants to move the Ship. An event can also contain additional quantitative information about the occurrence in form of event parameters. For example, the <code>PLAYER_SHIP_MOVE</code> signal is accompanied by the parameters <code>(x, y)</code> that contain the quantitative information as to where exactly to move the Ship. In QP, events are represented as instances of the <a class="el" href="struct_q_event.html" title="QEvent base class. ">QEvent</a> structure provided by the framework. Specifically, the <a class="el" href="struct_q_event.html" title="QEvent base class. ">QEvent</a> structure contains the member sig, to represent the signal of that event. Event parameters are added in the process of inheritance, as described in the sidebar <a class="el" href="derivation.html">Encapsulation and Single Inheritance in C</a>.</p>
<h1><a class="anchor" id="enumerating"></a>
6.1 Enumerating Event Signals and Defining Event Parameters</h1>
<p>Because events are explicitly shared among most of the application components, it is convenient to declare them in the separate header file game.h shown <a class="el" href="events.html#L6s1">Listing 6-1</a>. The explanation section immediately following the listing illuminates the interesting points.</p>
<p><a class="anchor" id="L6s1"></a><b>Listing 6-1 Signals, event structures, and active object interfaces defined in file game.h.</b> </p>
<div class="fragment"><div class="line"> (1) <span class="keyword">enum</span> GameSignals {                                 <span class="comment">// signals used in the game</span></div>
<div class="line"> (2)     TIME_TICK_SIG = <a class="code" href="qep_8h.html#ae35e58b2153d1c63307c068315be9074a6b922ebd3f2429b5b5e7b411675fda06">Q_USER_SIG</a>,                     <span class="comment">// published from tick ISR</span></div>
<div class="line">         PLAYER_TRIGGER_SIG,    <span class="comment">// published by Player (ISR) to trigger the Missile</span></div>
<div class="line">         PLAYER_QUIT_SIG,             <span class="comment">// published by Player (ISR) to quit the game</span></div>
<div class="line">         GAME_OVER_SIG,             <span class="comment">// published by Ship when it finishes exploding</span></div>
<div class="line"></div>
<div class="line">         <span class="comment">// insert other published signals here ...</span></div>
<div class="line"> (3)     MAX_PUB_SIG,                                  <span class="comment">// the last published signal</span></div>
<div class="line"></div>
<div class="line">         PLAYER_SHIP_MOVE_SIG,     <span class="comment">// posted by Player (ISR) to the Ship to move it</span></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">         BLINK_TIMEOUT_SIG,              <span class="comment">// signal for Tunnel&#39;s blink timeout event</span></div>
<div class="line">         SCREEN_TIMEOUT_SIG,            <span class="comment">// signal for Tunnel&#39;s screen timeout event</span></div>
<div class="line"></div>
<div class="line">         TAKE_OFF_SIG,       <span class="comment">// from Tunnel to Ship to grant permission to take off</span></div>
<div class="line">         HIT_WALL_SIG,               <span class="comment">// from Tunnel to Ship when Ship hits the wall</span></div>
<div class="line">         HIT_MINE_SIG,        <span class="comment">// from Mine to Ship or Missile when it hits the mine</span></div>
<div class="line">         SHIP_IMG_SIG,        <span class="comment">// from Ship to the Tunnel to draw and check for hits</span></div>
<div class="line">         MISSILE_IMG_SIG,     <span class="comment">// from Missile the Tunnel to draw and check for hits</span></div>
<div class="line">         MINE_IMG_SIG,               <span class="comment">// sent by Mine to the Tunnel to draw the mine</span></div>
<div class="line">         MISSILE_FIRE_SIG,                   <span class="comment">// sent by Ship to the Missile to fire</span></div>
<div class="line">         DESTROYED_MINE_SIG,    <span class="comment">// from Missile to Ship when Missile destroyed Mine</span></div>
<div class="line">         EXPLOSION_SIG,        <span class="comment">// from any exploding object to render the explosion</span></div>
<div class="line">         MINE_PLANT_SIG,                     <span class="comment">// from Tunnel to the Mine to plant it</span></div>
<div class="line">         MINE_DISABLED_SIG,         <span class="comment">// from Mine to Tunnel when it becomes disabled</span></div>
<div class="line">         MINE_RECYCLE_SIG,            <span class="comment">// sent by Tunnel to Mine to recycle the mine</span></div>
<div class="line">         SCORE_SIG,      <span class="comment">// from Ship to Tunnel to adjust game level based on score</span></div>
<div class="line"></div>
<div class="line"> (4)     MAX_SIG                              <span class="comment">// the last signal (keep always last)</span></div>
<div class="line">     };</div>
<div class="line"></div>
<div class="line"> (5) <span class="keyword">struct</span> ObjectPosEvt </div>
<div class="line"> (6)     : <span class="keyword">public</span> <a class="code" href="struct_q_event.html">QEvent</a>                            <span class="comment">// derive from the QEvent class</span></div>
<div class="line">     {          </div>
<div class="line"> (7)     <a class="code" href="qep__port_8h.html#a1add8b7f40b8c78daa5d7a2eb886c924">uint8_t</a> x;                                 <span class="comment">// the x-position of the object</span></div>
<div class="line"> (8)     <a class="code" href="qep__port_8h.html#a1add8b7f40b8c78daa5d7a2eb886c924">uint8_t</a> y;                                 <span class="comment">// new y-position of the object</span></div>
<div class="line">     };</div>
<div class="line"></div>
<div class="line">     <span class="keyword">struct </span>ObjectImageEvt : <span class="keyword">public</span> <a class="code" href="struct_q_event.html">QEvent</a> {        <span class="comment">// derive from the QEvent class</span></div>
<div class="line">         <a class="code" href="qep__port_8h.html#a1add8b7f40b8c78daa5d7a2eb886c924">uint8_t</a> x;                                 <span class="comment">// the x-position of the object</span></div>
<div class="line">         <a class="code" href="qep__port_8h.html#aef44329758059c91c76d334e8fc09700">int8_t</a>  y;                                 <span class="comment">// the y-position of the object</span></div>
<div class="line">         <a class="code" href="qep__port_8h.html#a1add8b7f40b8c78daa5d7a2eb886c924">uint8_t</a> bmp;                      <span class="comment">// the bitmap ID representing the object</span></div>
<div class="line">     };</div>
<div class="line"></div>
<div class="line">     <span class="keyword">struct </span>MineEvt : <span class="keyword">public</span> <a class="code" href="struct_q_event.html">QEvent</a> {               <span class="comment">// derive from the QEvent class</span></div>
<div class="line">         <a class="code" href="qep__port_8h.html#a1add8b7f40b8c78daa5d7a2eb886c924">uint8_t</a> id;                                          <span class="comment">// the ID of the Mine</span></div>
<div class="line">         MineEvt(<a class="code" href="qevent_8h.html#af55248e13cdc5784f0824c7615c41b7d">QSignal</a> sig, <a class="code" href="qep__port_8h.html#a1add8b7f40b8c78daa5d7a2eb886c924">uint8_t</a> <span class="keywordtype">id</span>) {</div>
<div class="line">             this-&gt;sig      = <a class="code" href="struct_q_event.html#af3f51670fdc402116309573cee25447d">sig</a>;</div>
<div class="line">             this-&gt;dynamic_ = 0;</div>
<div class="line">             this-&gt;<span class="keywordtype">id</span>       = id;</div>
<div class="line">         }</div>
<div class="line">     };</div>
<div class="line"></div>
<div class="line">     <span class="keyword">struct </span>ScoreEvt : <span class="keyword">public</span> <a class="code" href="struct_q_event.html">QEvent</a> {              <span class="comment">// derive from the QEvent class</span></div>
<div class="line">         <a class="code" href="qep__port_8h.html#a273cf69d639a59973b6019625df33e30">uint16_t</a> score;                                       <span class="comment">// the current score</span></div>
<div class="line">         ScoreEvt(<a class="code" href="qevent_8h.html#af55248e13cdc5784f0824c7615c41b7d">QSignal</a> sig, <a class="code" href="qep__port_8h.html#a273cf69d639a59973b6019625df33e30">uint16_t</a> score) {</div>
<div class="line">             this-&gt;sig      = <a class="code" href="struct_q_event.html#af3f51670fdc402116309573cee25447d">sig</a>;</div>
<div class="line">             this-&gt;dynamic_ = 0;</div>
<div class="line">             this-&gt;score    = score;</div>
<div class="line">         }</div>
<div class="line">     };</div>
<div class="line"></div>
<div class="line">     <span class="comment">// opaque pointers to active objects in the application</span></div>
<div class="line"> (9) <span class="keyword">extern</span> <a class="code" href="class_q_active.html">QActive</a> * <span class="keyword">const</span> AO_Tunnel;</div>
<div class="line">(10) <span class="keyword">extern</span> <a class="code" href="class_q_active.html">QActive</a> * <span class="keyword">const</span> AO_Ship;</div>
<div class="line">(11) <span class="keyword">extern</span> <a class="code" href="class_q_active.html">QActive</a> * <span class="keyword">const</span> AO_Missile;</div>
</div><!-- fragment --><ul>
<li>(1) In QP, signals of events are simply enumerated constants. Placing all signals in a single enumeration is particularly convenient to avoid inadvertent overlap in the numerical values of different signals.</li>
</ul>
<ul>
<li>(2) The application-level signals do not start from zero but rather are offset by the constant <a class="el" href="qep_8h.html#ae35e58b2153d1c63307c068315be9074a6b922ebd3f2429b5b5e7b411675fda06" title="signal to offset user signals ">Q_USER_SIG</a>. This is because QP reserves the lowest few signals for the internal use and provides the constant <a class="el" href="qep_8h.html#ae35e58b2153d1c63307c068315be9074a6b922ebd3f2429b5b5e7b411675fda06" title="signal to offset user signals ">Q_USER_SIG</a> as an offset from which user-level signals can start. Please also note that by convention, I attach the suffix <code>_SIG</code> to all signals so that I can easily distinguish signals from other constants. I drop the suffix <code>_SIG</code> in the state diagrams to reduce the clutter.</li>
</ul>
<ul>
<li>(3) The constant <code>MAX_PUB_SIG</code> delimits the published signals from the rest. The publish-subscribe event delivery mechanism consumes some RAM, which is proportional to the number of published signals. I save some RAM by providing the lower limit of published signals to QP (<code>MAX_PUB_SIG</code>) rather than maximum of all signals used in the application. (See also <a class="el" href="main_function.html#L3s1">Listing 3-1</a>(9)).</li>
</ul>
<ul>
<li>(4) The last enumeration <code>MAX_SIG</code> indicates the maximum of all signals used in the application.</li>
</ul>
<ul>
<li>(5) The event structure <code>ObjectPosEvt</code> defines a "class" of events that convey the object's position on the display in the event parameters.</li>
</ul>
<ul>
<li>(6) The structure <code>ObjectPosEvt</code> derives from the base structure <a class="el" href="struct_q_event.html" title="QEvent base class. ">QEvent</a>, as explained in the sidebar <a class="el" href="derivation.html">Encapsulation and Single Inheritance in C</a>.</li>
</ul>
<ul>
<li>(7-8) The structure <code>ObjectPosEvt</code> adds parameters <code>x</code> and <code>y</code>, which are coordinates of the object on the display.</li>
</ul>
<ul>
<li>(9-11) These global pointers represent active objects in the application and are used for posting events directly to active objects. Because the pointers can be initialized at compile time, I like to declare them const, sot that they can be placed in ROM. The active object pointers are "opaque", because they cannot access the whole active object, but only the part inherited from the <a class="el" href="class_q_active.html" title="Base class for derivation of application-level active object classes. ">QActive</a> structure. I'll have more to say about this in the next section.</li>
</ul>
<h1><a class="anchor" id="generating"></a>
6.2 Generating, Posting, and Publishing Events</h1>
<p>The <a class="el" href="class_q_f.html" title="QF services. ">QF</a> framework supports two types of asynchronous event exchange:</p>
<ol type="1">
<li>The simple mechanism of direct event posting supported through the functions <a class="el" href="class_q_active.html#a0bb23424140a4910fde355d04f55c6e1" title="Posts an event e directly to the event queue of the acitve object me using the First-In-First-Out (FI...">QActive::postFIFO()</a> and <a class="el" href="class_q_active.html#a6c2deb168c17567ab6bbc2178d67878d" title="Posts an event directly to the event queue of the active object me using the Last-In-First-Out (LIFO)...">QActive::postLIFO()</a>, where the producer of an event directly posts the event to the event queue of the consumer active object.</li>
<li>A more sophisticated publish-subscribe event delivery mechanism supported through the functions <a class="el" href="class_q_f.html#a65c4972ea4b86162d51fc5ca802fb7bc" title="Publish event to the framework. ">QF::publish()</a> and <a class="el" href="class_q_active.html#aa2145cfedf8c4616dacdbf0b7609d8f2" title="Subscribes for delivery of signal sig to the active object. ">QActive::subscribe()</a>, where the producers of the events "publish" them to the framework, and the framework then delivers the events to all active objects that had "subscribed" to these events.</li>
</ol>
<p>In <a class="el" href="class_q_f.html" title="QF services. ">QF</a>, any part of the system can produce events, not necessarily only the active objects. For example, interrupt service routines (ISRs) or device drivers can also produce events. On the other hand, only active objects can consume events, because only active objects have event queues.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="class_q_f.html" title="QF services. ">QF</a> also provides "raw" thread-safe event queues (struct <a class="el" href="class_q_e_queue.html" title="Native QF Event Queue class. ">QEQueue</a>), which can consume events as well. These "raw" thread-safe queues cannot block and are intended to deliver events to ISRs or device drivers. Please refer to Chapter 7 of <a class="el" href="index.html#PSiCC2">Practical UML Statecharts in C/C++, Second Edition</a> for more details.</dd></dl>
<p>The most important characteristic of event management in <a class="el" href="class_q_f.html" title="QF services. ">QF</a> is that the framework passes around only pointers to events, not the events themselves. <a class="el" href="class_q_f.html" title="QF services. ">QF</a> never copies the events by value ("zero-copy" policy); even in case of publishing events that often involves multicasting the same event to multiple subscribers. The actual event instances are either constant events statically allocated at compile time, or dynamic events allocated at runtime from one of the event pools that the framework manages. <a class="el" href="events.html#L6s2">Listing 6-2</a> provides examples of publishing static events and posting dynamic events from the interrupt service routines (ISRs) of the "Fly 'n' Shoot" version for the ARM-Cortex board (file <code>&lt;qpcpp&gt;\examples\arm-cortex\vanilla\iar\game-ev-lm3s811\bsp.cpp</code>). In the upcoming Section <a class="el" href="coding_hsm.html"><ol type="1">
<li>Coding Hierarchical State Machines</li>
</ol>
</a> you will see other examples of event posting from active objects in the state machine code.</p>
<p><a class="anchor" id="L6s2"></a><b>Listing 6-2 Generating, posting , and publishing events from the ISRs in bsp.cpp for the ARM-Cortex board.</b> </p>
<div class="fragment"><div class="line"> (1) <span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> <span class="keywordtype">void</span> ISR_SysTick(<span class="keywordtype">void</span>) {</div>
<div class="line"> (2)     <span class="keyword">static</span> <a class="code" href="struct_q_event.html">QEvent</a> <span class="keyword">const</span> tickEvt = { TIME_TICK_SIG, 0 };</div>
<div class="line"> (3)     <a class="code" href="class_q_f.html#a65c4972ea4b86162d51fc5ca802fb7bc">QF::publish</a>(&amp;tickEvt);        <span class="comment">// publish the tick event to all subscribers</span></div>
<div class="line"> (4)     <a class="code" href="class_q_f.html#aee589dbe41a722dd412826c6a8b69c2e">QF::tick</a>();                               <span class="comment">// process all armed time events</span></div>
<div class="line">     }</div>
<div class="line">     <span class="comment">//............................................................................</span></div>
<div class="line"> (5) <span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> <span class="keywordtype">void</span> ISR_ADC(<span class="keywordtype">void</span>) {</div>
<div class="line">         <span class="keyword">static</span> <a class="code" href="qep__port_8h.html#a06896e8c53f721507066c079052171f8">uint32_t</a> adcLPS = 0;               <span class="comment">// Low-Pass-Filtered ADC reading</span></div>
<div class="line">         <span class="keyword">static</span> <a class="code" href="qep__port_8h.html#a06896e8c53f721507066c079052171f8">uint32_t</a> wheel = 0;                      <span class="comment">// the last wheel position</span></div>
<div class="line"></div>
<div class="line">         <span class="keyword">static</span> <a class="code" href="qep__port_8h.html#a06896e8c53f721507066c079052171f8">uint32_t</a> btn_debounced  = 0;</div>
<div class="line">         <span class="keyword">static</span> <a class="code" href="qep__port_8h.html#a1add8b7f40b8c78daa5d7a2eb886c924">uint8_t</a>  debounce_state = 0;</div>
<div class="line"></div>
<div class="line">         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> tmp;</div>
<div class="line"></div>
<div class="line">         ADCIntClear(ADC_BASE, 3);                       <span class="comment">// clear the ADC interrupt</span></div>
<div class="line"> (6)     ADCSequenceDataGet(ADC_BASE, 3, &amp;tmp);       <span class="comment">// read the data from the ADC</span></div>
<div class="line"></div>
<div class="line">          <span class="comment">// 1st order low-pass filter: time constant ~= 2^n samples</span></div>
<div class="line">          <span class="comment">// TF = (1/2^n)/(z-((2^n - 1)/2^n)),</span></div>
<div class="line">          <span class="comment">// eg, n=3, y(k+1) = y(k) - y(k)/8 + x(k)/8 =&gt; y += (x - y)/8</span></div>
<div class="line"> (7)     adcLPS += (((<span class="keywordtype">int</span>)tmp - (int)adcLPS + 4) &gt;&gt; 3);          <span class="comment">// Low-Pass-Filter</span></div>
<div class="line"></div>
<div class="line">            <span class="comment">// compute the next position of the wheel</span></div>
<div class="line"> (8)     tmp = (((1 &lt;&lt; 10) - adcLPS)*(BSP_SCREEN_HEIGHT - 2)) &gt;&gt; 10;</div>
<div class="line"></div>
<div class="line">         <span class="keywordflow">if</span> (tmp != wheel) {                      <span class="comment">// did the wheel position change?</span></div>
<div class="line"> (9)         ObjectPosEvt *ope = <a class="code" href="qf_8h.html#abd823f3a9e8b3206a3460a108d5fa3e3">Q_NEW</a>(ObjectPosEvt, PLAYER_SHIP_MOVE_SIG);</div>
<div class="line">(10)         ope-&gt;x = (<a class="code" href="qep__port_8h.html#a1add8b7f40b8c78daa5d7a2eb886c924">uint8_t</a>)GAME_SHIP_X;                  <span class="comment">// x-position is fixed</span></div>
<div class="line">(11)         ope-&gt;y = (<a class="code" href="qep__port_8h.html#a1add8b7f40b8c78daa5d7a2eb886c924">uint8_t</a>)tmp;</div>
<div class="line">(12)         AO_Ship-&gt;postFIFO(ope);                            <span class="comment">// post to the Ship</span></div>
<div class="line">             wheel = tmp;                    <span class="comment">// save the last position of the wheel</span></div>
<div class="line">         }</div>
<div class="line">         . . .</div>
<div class="line">     }</div>
</div><!-- fragment --><ul>
<li>(1) In the case of the ARM-Cortex board, the function ISR_SysTick() services the system clock tick ISR generated by the ARM-Cortex system tick timer.</li>
</ul>
<ul>
<li>(2) The <code>TIME_TICK</code> event never changes, so it can be statically allocated just once. This event is declared as const, which means that it can be placed in ROM. The initializer list for this event consists of the signal <code>TIME_TICK_SIG</code> followed by zero. This zero informs the <a class="el" href="class_q_f.html" title="QF services. ">QF</a> framework that this event is static and should never be recycled to an event pool.</li>
</ul>
<ul>
<li>(3) The ISR calls the framework function <a class="el" href="class_q_f.html#a65c4972ea4b86162d51fc5ca802fb7bc" title="Publish event to the framework. ">QF::publish()</a>, which takes the pointer to the tickEvt event to deliver to all subscribers.</li>
</ul>
<ul>
<li>(4) The ISR calls the function <a class="el" href="class_q_f.html#aee589dbe41a722dd412826c6a8b69c2e" title="Processes all armed time events at every clock tick. ">QF::tick()</a>, in which it the framework manages the armed time events.</li>
</ul>
<ul>
<li>(5) The function <code>ISR_ADC()</code> services the ADC conversions, which ultimately deliver the position of the Ship.</li>
</ul>
<ul>
<li>(6) The ISR reads the data from the ADC.</li>
</ul>
<ul>
<li>(7-8) A low-pass filter is applied to the raw ADC reading and the potentiometer wheel position is computed.</li>
</ul>
<ul>
<li>(9) The <a class="el" href="class_q_f.html" title="QF services. ">QF</a> macro <code><a class="el" href="qf_8h.html#abd823f3a9e8b3206a3460a108d5fa3e3" title="Allocate a dynamic event. ">Q_NEW(ObjectPosEvt, PLAYER_SHIP_MOVE_SIG)</a></code> dynamically allocates an instance of the ObjectPosEvt event from an event pool managed by <a class="el" href="class_q_f.html" title="QF services. ">QF</a>. The macro also performs the association between the signal <code>PLAYER_SHIP_MOVE_SIG</code> and the allocated event. The <a class="el" href="qf_8h.html#abd823f3a9e8b3206a3460a108d5fa3e3" title="Allocate a dynamic event. ">Q_NEW()</a> macro returns the pointer to the allocated event.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>The <code>PLAYER_SHIP_MOVE(x, y)</code> event is an example of an event with changing parameters. In general, such an event cannot be allocated statically (like the <code>TIME_TICK</code> event at label (2)) because it can change asynchronously next time the ISR executes. Some active objects in the system might still be referring to the event via a pointer, so the event should not be changing. Dynamic event allocation of <a class="el" href="class_q_f.html" title="QF services. ">QF</a> solves all such concurrency issues, because every time a new event is allocated. <a class="el" href="class_q_f.html" title="QF services. ">QF</a> then recycles the dynamic events, after it determines that all active objects are done with accessing the events.</dd></dl>
<ul>
<li>(10-11) The <code>x</code> and <code>y</code> parameters of the event are assigned.</li>
</ul>
<ul>
<li>(12) The dynamic event is posted directly to the Ship active object.</li>
</ul>
<p>Prev: <a class="el" href="active_objects.html"><ol type="1">
<li>Elaborating State Machines of Active Objects</li>
</ol>
</a> <br/>
Next: <a class="el" href="coding_hsm.html"><ol type="1">
<li>Coding Hierarchical State Machines</li>
</ol>
</a></p>
<div class="image">
<img src="logo_ql_TM.jpg" alt="logo_ql_TM.jpg"/>
</div>
<p> Copyright &copy; 2002-2011 Quantum Leaps, LLC. All Rights Reserved.<br/>
<a href="http://www.state-machine.com">http://www.state-machine.com</a> </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Nov 28 2016 21:26:18 for QP/C++ by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
