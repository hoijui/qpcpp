<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>QP/C++: QF Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">QP/C++
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_q_f-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">QF Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="class_q_f.html" title="QF services. ">QF</a> services.  
 <a href="class_q_f.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="qf_8h_source.html">qf.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a6ad3fc234e46c8a32ea9458533db229b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_f.html#a6ad3fc234e46c8a32ea9458533db229b">init</a> (void)</td></tr>
<tr class="memdesc:a6ad3fc234e46c8a32ea9458533db229b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_q_f.html" title="QF services. ">QF</a> initialization.  <a href="#a6ad3fc234e46c8a32ea9458533db229b">More...</a><br/></td></tr>
<tr class="separator:a6ad3fc234e46c8a32ea9458533db229b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ce01adc2cf6db212a036306ee03bd33"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_f.html#a3ce01adc2cf6db212a036306ee03bd33">psInit</a> (<a class="el" href="class_q_subscr_list.html">QSubscrList</a> *subscrSto, <a class="el" href="qevent_8h.html#af55248e13cdc5784f0824c7615c41b7d">QSignal</a> maxSignal)</td></tr>
<tr class="memdesc:a3ce01adc2cf6db212a036306ee03bd33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish-subscribe initialization.  <a href="#a3ce01adc2cf6db212a036306ee03bd33">More...</a><br/></td></tr>
<tr class="separator:a3ce01adc2cf6db212a036306ee03bd33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5defbf03f35eb4bcef9eee150e42821d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_f.html#a5defbf03f35eb4bcef9eee150e42821d">poolInit</a> (void *poolSto, <a class="el" href="qep__port_8h.html#a06896e8c53f721507066c079052171f8">uint32_t</a> poolSize, QEventSize evtSize)</td></tr>
<tr class="memdesc:a5defbf03f35eb4bcef9eee150e42821d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event pool initialization for dynamic allocation of events.  <a href="#a5defbf03f35eb4bcef9eee150e42821d">More...</a><br/></td></tr>
<tr class="separator:a5defbf03f35eb4bcef9eee150e42821d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09b2df3e8eb5f22cd401cd637c40f369"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_f.html#a09b2df3e8eb5f22cd401cd637c40f369">run</a> (void)</td></tr>
<tr class="memdesc:a09b2df3e8eb5f22cd401cd637c40f369"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfers control to <a class="el" href="class_q_f.html" title="QF services. ">QF</a> to run the application.  <a href="#a09b2df3e8eb5f22cd401cd637c40f369">More...</a><br/></td></tr>
<tr class="separator:a09b2df3e8eb5f22cd401cd637c40f369"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27e969500c797c2939cf8bec05273be2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_f.html#a27e969500c797c2939cf8bec05273be2">onStartup</a> (void)</td></tr>
<tr class="memdesc:a27e969500c797c2939cf8bec05273be2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Startup <a class="el" href="class_q_f.html" title="QF services. ">QF</a> callback.  <a href="#a27e969500c797c2939cf8bec05273be2">More...</a><br/></td></tr>
<tr class="separator:a27e969500c797c2939cf8bec05273be2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9569a5e1a10e536650109855cd89af47"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_f.html#a9569a5e1a10e536650109855cd89af47">onCleanup</a> (void)</td></tr>
<tr class="memdesc:a9569a5e1a10e536650109855cd89af47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cleanup <a class="el" href="class_q_f.html" title="QF services. ">QF</a> callback.  <a href="#a9569a5e1a10e536650109855cd89af47">More...</a><br/></td></tr>
<tr class="separator:a9569a5e1a10e536650109855cd89af47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a8e5a6ad959cd7cf52eed88cbdad20c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_f.html#a1a8e5a6ad959cd7cf52eed88cbdad20c">stop</a> (void)</td></tr>
<tr class="memdesc:a1a8e5a6ad959cd7cf52eed88cbdad20c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function invoked by the application layer to stop the <a class="el" href="class_q_f.html" title="QF services. ">QF</a> application and return control to the OS/Kernel.  <a href="#a1a8e5a6ad959cd7cf52eed88cbdad20c">More...</a><br/></td></tr>
<tr class="separator:a1a8e5a6ad959cd7cf52eed88cbdad20c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65c4972ea4b86162d51fc5ca802fb7bc"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_f.html#a65c4972ea4b86162d51fc5ca802fb7bc">publish</a> (<a class="el" href="struct_q_event.html">QEvent</a> const *e, void const *sender)</td></tr>
<tr class="memdesc:a65c4972ea4b86162d51fc5ca802fb7bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish event to the framework.  <a href="#a65c4972ea4b86162d51fc5ca802fb7bc">More...</a><br/></td></tr>
<tr class="separator:a65c4972ea4b86162d51fc5ca802fb7bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee589dbe41a722dd412826c6a8b69c2e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_f.html#aee589dbe41a722dd412826c6a8b69c2e">tick</a> (void const *sender)</td></tr>
<tr class="memdesc:aee589dbe41a722dd412826c6a8b69c2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Processes all armed time events at every clock tick.  <a href="#aee589dbe41a722dd412826c6a8b69c2e">More...</a><br/></td></tr>
<tr class="separator:aee589dbe41a722dd412826c6a8b69c2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea5335373a13d20f56099a0cfdfa723e"><td class="memItemLeft" align="right" valign="top">static char const <a class="el" href="qevent_8h.html#a4f4cc7253c4d809b326498b40efd66d3">Q_ROM</a> *<a class="el" href="qevent_8h.html#ac4b8d7dd267fd787a004ad9b58ec2283">Q_ROM_VAR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_f.html#aea5335373a13d20f56099a0cfdfa723e">getVersion</a> (void)</td></tr>
<tr class="memdesc:aea5335373a13d20f56099a0cfdfa723e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="class_q_f.html" title="QF services. ">QF</a> version.  <a href="#aea5335373a13d20f56099a0cfdfa723e">More...</a><br/></td></tr>
<tr class="separator:aea5335373a13d20f56099a0cfdfa723e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8753eb3f87b739ddf49fd73357a762d1"><td class="memItemLeft" align="right" valign="top">static char const <a class="el" href="qevent_8h.html#a4f4cc7253c4d809b326498b40efd66d3">Q_ROM</a> *<a class="el" href="qevent_8h.html#ac4b8d7dd267fd787a004ad9b58ec2283">Q_ROM_VAR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_f.html#a8753eb3f87b739ddf49fd73357a762d1">getPortVersion</a> (void)</td></tr>
<tr class="memdesc:a8753eb3f87b739ddf49fd73357a762d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the QF-port version.  <a href="#a8753eb3f87b739ddf49fd73357a762d1">More...</a><br/></td></tr>
<tr class="separator:a8753eb3f87b739ddf49fd73357a762d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b72df3c92fc6ead554963443762ca22"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="qep__port_8h.html#a06896e8c53f721507066c079052171f8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_f.html#a7b72df3c92fc6ead554963443762ca22">getPoolMargin</a> (<a class="el" href="qep__port_8h.html#a1add8b7f40b8c78daa5d7a2eb886c924">uint8_t</a> poolId)</td></tr>
<tr class="memdesc:a7b72df3c92fc6ead554963443762ca22"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the margin of the given event pool.  <a href="#a7b72df3c92fc6ead554963443762ca22">More...</a><br/></td></tr>
<tr class="separator:a7b72df3c92fc6ead554963443762ca22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6cc651557aaa4040db1995982b1244f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="qep__port_8h.html#a06896e8c53f721507066c079052171f8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_f.html#af6cc651557aaa4040db1995982b1244f">getQueueMargin</a> (<a class="el" href="qep__port_8h.html#a1add8b7f40b8c78daa5d7a2eb886c924">uint8_t</a> prio)</td></tr>
<tr class="memdesc:af6cc651557aaa4040db1995982b1244f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the margin of the given event queue.  <a href="#af6cc651557aaa4040db1995982b1244f">More...</a><br/></td></tr>
<tr class="separator:af6cc651557aaa4040db1995982b1244f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0372670610b5d72a5e985503e2ba0b6b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct_q_event.html">QEvent</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_f.html#a0372670610b5d72a5e985503e2ba0b6b">new_</a> (<a class="el" href="qep__port_8h.html#a273cf69d639a59973b6019625df33e30">uint16_t</a> evtSize, <a class="el" href="qevent_8h.html#af55248e13cdc5784f0824c7615c41b7d">QSignal</a> sig)</td></tr>
<tr class="memdesc:a0372670610b5d72a5e985503e2ba0b6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal <a class="el" href="class_q_f.html" title="QF services. ">QF</a> implementation of the dynamic event allocator.  <a href="#a0372670610b5d72a5e985503e2ba0b6b">More...</a><br/></td></tr>
<tr class="separator:a0372670610b5d72a5e985503e2ba0b6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10497af0567c730737b33e46cf2ffd6c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_f.html#a10497af0567c730737b33e46cf2ffd6c">gc</a> (<a class="el" href="struct_q_event.html">QEvent</a> const *e)</td></tr>
<tr class="memdesc:a10497af0567c730737b33e46cf2ffd6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recycle a dynamic event.  <a href="#a10497af0567c730737b33e46cf2ffd6c">More...</a><br/></td></tr>
<tr class="separator:a10497af0567c730737b33e46cf2ffd6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0032e774fcf6293d2136e960fcc48528"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_f.html#a0032e774fcf6293d2136e960fcc48528">remove_</a> (<a class="el" href="class_q_active.html">QActive</a> const *a)</td></tr>
<tr class="memdesc:a0032e774fcf6293d2136e960fcc48528"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the active object from the framework.  <a href="#a0032e774fcf6293d2136e960fcc48528">More...</a><br/></td></tr>
<tr class="separator:a0032e774fcf6293d2136e960fcc48528"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a82e692a5232ab9f5226168f345a2af11"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_q_active.html">QActive</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_q_f.html#a82e692a5232ab9f5226168f345a2af11">active_</a> []</td></tr>
<tr class="memdesc:a82e692a5232ab9f5226168f345a2af11"><td class="mdescLeft">&#160;</td><td class="mdescRight">array of registered active objects  <a href="#a82e692a5232ab9f5226168f345a2af11">More...</a><br/></td></tr>
<tr class="separator:a82e692a5232ab9f5226168f345a2af11"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a1bd057458f70978840c6f18b891ea07f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1bd057458f70978840c6f18b891ea07f"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>QActive</b></td></tr>
<tr class="separator:a1bd057458f70978840c6f18b891ea07f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="class_q_f.html" title="QF services. ">QF</a> services. </p>
<p>This class groups together <a class="el" href="class_q_f.html" title="QF services. ">QF</a> services. It has only static members and should not be instantiated. </p>

<p>Definition at line <a class="el" href="qf_8h_source.html#l00621">621</a> of file <a class="el" href="qf_8h_source.html">qf.h</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a10497af0567c730737b33e46cf2ffd6c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void QF::gc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_q_event.html">QEvent</a> const *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recycle a dynamic event. </p>
<p>This function implements a simple garbage collector for the dynamic events. Only dynamic events are candidates for recycling. (A dynamic event is one that is allocated from an event pool, which is determined as non-zero e-&gt;attrQF__ attribute.) Next, the function decrements the reference counter of the event, and recycles the event only if the counter drops to zero (meaning that no more references are outstanding for this event). The dynamic event is recycled by returning it to the pool from which it was originally allocated. The pool-of-origin information is stored in the upper 2-MSBs of the e-&gt;attrQF__ attribute.)</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="class_q_f.html" title="QF services. ">QF</a> invokes the garbage collector at all appropriate contexts, when an event can become garbage (automatic garbage collection), so the application code should have NO need to call <a class="el" href="class_q_f.html#a10497af0567c730737b33e46cf2ffd6c" title="Recycle a dynamic event. ">QF::gc()</a> directly. The <a class="el" href="class_q_f.html#a10497af0567c730737b33e46cf2ffd6c" title="Recycle a dynamic event. ">QF::gc()</a> function is exposed only for special cases when your application sends dynamic events to the "raw" thread-safe queues (see <a class="el" href="class_q_e_queue.html" title="Native QF Event Queue class. ">QEQueue</a>). Such queues are processed outside of <a class="el" href="class_q_f.html" title="QF services. ">QF</a> and the automatic garbage collection CANNOT be performed for these events. In this case you need to call <a class="el" href="class_q_f.html#a10497af0567c730737b33e46cf2ffd6c" title="Recycle a dynamic event. ">QF::gc()</a> explicitly. </dd></dl>

<p>Definition at line <a class="el" href="qf__gc_8cpp_source.html#l00042">42</a> of file <a class="el" href="qf__gc_8cpp_source.html">qf_gc.cpp</a>.</p>

<p>References <a class="el" href="qf__pkg_8h_source.html#l00103">EVT_DEC_REF_CTR</a>, <a class="el" href="qf__pkg_8h_source.html#l00094">EVT_POOL_ID</a>, <a class="el" href="qf__pkg_8h_source.html#l00097">EVT_REF_CTR</a>, <a class="el" href="qassert_8h_source.html#l00101">Q_ASSERT</a>, <a class="el" href="qk_8h_source.html#l00182">QF_EPOOL_PUT_</a>, <a class="el" href="qs_8h_source.html#l00711">QS_BEGIN_NOCRIT_</a>, <a class="el" href="qs_8h_source.html#l00722">QS_END_NOCRIT_</a>, <a class="el" href="qs_8h_source.html#l00087">QS_QF_GC</a>, <a class="el" href="qs_8h_source.html#l00086">QS_QF_GC_ATTEMPT</a>, <a class="el" href="qs_8h_source.html#l00169">QS_TIME_</a>, and <a class="el" href="qs_8h_source.html#l00727">QS_U8_</a>.</p>

<p>Referenced by <a class="el" href="qk__sched_8cpp_source.html#l00051">QK_sched_()</a>, <a class="el" href="qk__ext_8cpp_source.html#l00051">QK_schedExt_()</a>, and <a class="el" href="qa__run_8cpp_source.html#l00039">QActive::run()</a>.</p>

</div>
</div>
<a class="anchor" id="a7b72df3c92fc6ead554963443762ca22"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="qep__port_8h.html#a06896e8c53f721507066c079052171f8">uint32_t</a> QF::getPoolMargin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qep__port_8h.html#a1add8b7f40b8c78daa5d7a2eb886c924">uint8_t</a>&#160;</td>
          <td class="paramname"><em>poolId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function returns the margin of the given event pool. </p>
<p>This function returns the margin of the given event pool <em>poolId</em>, where poolId is the ID of the pool initialized by the call to <a class="el" href="class_q_f.html#a5defbf03f35eb4bcef9eee150e42821d" title="Event pool initialization for dynamic allocation of events. ">QF::poolInit()</a>. The poolId of the first initialized pool is 1, the second 2, and so on.</p>
<p>The returned pool margin is the minimal number of free blocks encountered in the given pool since system startup.</p>
<dl class="section note"><dt>Note</dt><dd>Requesting the margin of an un-initialized pool raises an assertion in the <a class="el" href="class_q_f.html" title="QF services. ">QF</a>. </dd></dl>

<p>Definition at line <a class="el" href="qmp__get_8cpp_source.html#l00066">66</a> of file <a class="el" href="qmp__get_8cpp_source.html">qmp_get.cpp</a>.</p>

<p>References <a class="el" href="qassert_8h_source.html#l00171">Q_REQUIRE</a>.</p>

</div>
</div>
<a class="anchor" id="a8753eb3f87b739ddf49fd73357a762d1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char const <a class="el" href="qevent_8h.html#a4f4cc7253c4d809b326498b40efd66d3">Q_ROM</a> *<a class="el" href="qevent_8h.html#ac4b8d7dd267fd787a004ad9b58ec2283">Q_ROM_VAR</a> QF::getPortVersion </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the QF-port version. </p>
<p>This function returns constant version string in the format x.y.zz, where x (one digit) is the major version, y (one digit) is the minor version, and zz (two digits) is the maintenance release version. An example of the QF-port version string is "1.1.03".</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_q_f.html#aea5335373a13d20f56099a0cfdfa723e" title="Returns the QF version. ">QF::getVersion()</a> </dd></dl>

<p>Definition at line <a class="el" href="qvanilla_8cpp_source.html#l00056">56</a> of file <a class="el" href="qvanilla_8cpp_source.html">qvanilla.cpp</a>.</p>

<p>References <a class="el" href="qevent_8h_source.html#l00063">Q_ROM</a>.</p>

</div>
</div>
<a class="anchor" id="af6cc651557aaa4040db1995982b1244f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="qep__port_8h.html#a06896e8c53f721507066c079052171f8">uint32_t</a> QF::getQueueMargin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qep__port_8h.html#a1add8b7f40b8c78daa5d7a2eb886c924">uint8_t</a>&#160;</td>
          <td class="paramname"><em>prio</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function returns the margin of the given event queue. </p>
<p>This function returns the margin of the given event queue of an active object with priority <em>prio</em>. (<a class="el" href="class_q_f.html" title="QF services. ">QF</a> priorities start with 1 and go up to <a class="el" href="qf__port_8h.html#a776d2a032974db4bf9bcfde01ace1389" title="The maximum number of active objects in the application. ">QF_MAX_ACTIVE</a>.) The margin is the minimal number of free events encountered in the given queue since system startup.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="class_q_f.html#af6cc651557aaa4040db1995982b1244f" title="This function returns the margin of the given event queue. ">QF::getQueueMargin()</a> is available only when the native <a class="el" href="class_q_f.html" title="QF services. ">QF</a> event queue implementation is used. Requesting the queue margin of an unused priority level raises an assertion in the <a class="el" href="class_q_f.html" title="QF services. ">QF</a>. (A priority level becomes used in <a class="el" href="class_q_f.html" title="QF services. ">QF</a> after the call to the QF::add_() function.) </dd></dl>

<p>Definition at line <a class="el" href="qa__get___8cpp_source.html#l00088">88</a> of file <a class="el" href="qa__get___8cpp_source.html">qa_get_.cpp</a>.</p>

<p>References <a class="el" href="qassert_8h_source.html#l00171">Q_REQUIRE</a>, and <a class="el" href="qf__port_8h_source.html#l00051">QF_MAX_ACTIVE</a>.</p>

</div>
</div>
<a class="anchor" id="aea5335373a13d20f56099a0cfdfa723e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char <a class="el" href="qevent_8h.html#a4f4cc7253c4d809b326498b40efd66d3">Q_ROM</a> *<a class="el" href="qevent_8h.html#ac4b8d7dd267fd787a004ad9b58ec2283">Q_ROM_VAR</a> QF::getVersion </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="class_q_f.html" title="QF services. ">QF</a> version. </p>
<p>This function returns constant version string in the format x.y.zz, where x (one digit) is the major version, y (one digit) is the minor version, and zz (two digits) is the maintenance release version. An example of the version string is "3.1.03".</p>
<p>The following example illustrates the usage of this function: </p>
<div class="fragment"><div class="line">printf(<span class="stringliteral">&quot;Quantum DPP\nQEP %s\nQF  %s, QF port %s\n&quot;</span></div>
<div class="line">       <span class="stringliteral">&quot;Press ESC to quit...\n&quot;</span>,</div>
<div class="line">       <a class="code" href="class_q_e_p.html#a6ebe00c8d3227c7421885eee6d626f06">QEP::getVersion</a>(),                                       <span class="comment">// QEP version</span></div>
<div class="line">       <a class="code" href="class_q_f.html#aea5335373a13d20f56099a0cfdfa723e">QF::getVersion</a>(),                                         <span class="comment">// QF version</span></div>
<div class="line">       <a class="code" href="class_q_f.html#a8753eb3f87b739ddf49fd73357a762d1">QF::getPortVersion</a>());                               <span class="comment">// QF-port version</span></div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="qf__act_8cpp_source.html#l00048">48</a> of file <a class="el" href="qf__act_8cpp_source.html">qf_act.cpp</a>.</p>

<p>References <a class="el" href="qevent_8h_source.html#l00063">Q_ROM</a>, <a class="el" href="qevent_8h_source.html#l00079">Q_ROM_VAR</a>, and <a class="el" href="qevent_8h_source.html#l00048">QP_VERSION</a>.</p>

</div>
</div>
<a class="anchor" id="a6ad3fc234e46c8a32ea9458533db229b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void QF::init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_q_f.html" title="QF services. ">QF</a> initialization. </p>
<p>This function initializes <a class="el" href="class_q_f.html" title="QF services. ">QF</a> and must be called exactly once before any other <a class="el" href="class_q_f.html" title="QF services. ">QF</a> function. </p>

<p>Definition at line <a class="el" href="qvanilla_8cpp_source.html#l00061">61</a> of file <a class="el" href="qvanilla_8cpp_source.html">qvanilla.cpp</a>.</p>

<p>Referenced by <a class="el" href="lint__qk__4_81_807_8txt_source.html#l00021">QK::getVersion()</a>.</p>

</div>
</div>
<a class="anchor" id="a0372670610b5d72a5e985503e2ba0b6b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_q_event.html">QEvent</a> * QF::new_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qep__port_8h.html#a273cf69d639a59973b6019625df33e30">uint16_t</a>&#160;</td>
          <td class="paramname"><em>evtSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="qevent_8h.html#af55248e13cdc5784f0824c7615c41b7d">QSignal</a>&#160;</td>
          <td class="paramname"><em>sig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal <a class="el" href="class_q_f.html" title="QF services. ">QF</a> implementation of the dynamic event allocator. </p>
<dl class="section note"><dt>Note</dt><dd>The application code should not call this function directly. Please use the macro <a class="el" href="qf_8h.html#abd823f3a9e8b3206a3460a108d5fa3e3" title="Allocate a dynamic event. ">Q_NEW</a>. </dd></dl>

<p>Definition at line <a class="el" href="qf__new_8cpp_source.html#l00042">42</a> of file <a class="el" href="qf__new_8cpp_source.html">qf_new.cpp</a>.</p>

<p>References <a class="el" href="qf__pkg_8h_source.html#l00094">EVT_POOL_ID</a>, <a class="el" href="qf__pkg_8h_source.html#l00097">EVT_REF_CTR</a>, <a class="el" href="qassert_8h_source.html#l00101">Q_ASSERT</a>, <a class="el" href="qk_8h_source.html#l00166">QF_EPOOL_EVENT_SIZE_</a>, <a class="el" href="qk_8h_source.html#l00174">QF_EPOOL_GET_</a>, <a class="el" href="qs_8h_source.html#l00691">QS_BEGIN_</a>, <a class="el" href="qs_8h_source.html#l00631">QS_CRIT_STAT_</a>, <a class="el" href="qs_8h_source.html#l00702">QS_END_</a>, <a class="el" href="qs_8h_source.html#l00085">QS_QF_NEW</a>, <a class="el" href="qs_8h_source.html#l00169">QS_TIME_</a>, and <a class="el" href="qevent_8h_source.html#l00140">QEvent::sig</a>.</p>

</div>
</div>
<a class="anchor" id="a9569a5e1a10e536650109855cd89af47"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void QF::onCleanup </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cleanup <a class="el" href="class_q_f.html" title="QF services. ">QF</a> callback. </p>
<p><a class="el" href="class_q_f.html#a9569a5e1a10e536650109855cd89af47" title="Cleanup QF callback. ">QF::onCleanup()</a> is called in some <a class="el" href="class_q_f.html" title="QF services. ">QF</a> ports before <a class="el" href="class_q_f.html" title="QF services. ">QF</a> returns to the underlying operating system or RTOS.</p>
<p>This function is strongly platform-specific and is not implemented in the <a class="el" href="class_q_f.html" title="QF services. ">QF</a> but either in the <a class="el" href="class_q_f.html" title="QF services. ">QF</a> port or in the Board Support Package (BSP) for the given application. Some <a class="el" href="class_q_f.html" title="QF services. ">QF</a> ports might not require implementing <a class="el" href="class_q_f.html#a9569a5e1a10e536650109855cd89af47" title="Cleanup QF callback. ">QF::onCleanup()</a> at all, because many embedded applications don't have anything to exit to.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_q_f.html#a6ad3fc234e46c8a32ea9458533db229b" title="QF initialization. ">QF::init()</a> and <a class="el" href="class_q_f.html#a1a8e5a6ad959cd7cf52eed88cbdad20c" title="Function invoked by the application layer to stop the QF application and return control to the OS/Ker...">QF::stop()</a> </dd></dl>

<p>Referenced by <a class="el" href="qvanilla_8cpp_source.html#l00065">stop()</a>.</p>

</div>
</div>
<a class="anchor" id="a27e969500c797c2939cf8bec05273be2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void QF::onStartup </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Startup <a class="el" href="class_q_f.html" title="QF services. ">QF</a> callback. </p>
<p>The timeline for calling <a class="el" href="class_q_f.html#a27e969500c797c2939cf8bec05273be2" title="Startup QF callback. ">QF::onStartup()</a> depends on the particular <a class="el" href="class_q_f.html" title="QF services. ">QF</a> port. In most cases, <a class="el" href="class_q_f.html#a27e969500c797c2939cf8bec05273be2" title="Startup QF callback. ">QF::onStartup()</a> is called from <a class="el" href="class_q_f.html#a09b2df3e8eb5f22cd401cd637c40f369" title="Transfers control to QF to run the application. ">QF::run()</a>, right before starting any multitasking kernel or the background loop. </p>

<p>Referenced by <a class="el" href="qvanilla_8cpp_source.html#l00070">run()</a>.</p>

</div>
</div>
<a class="anchor" id="a5defbf03f35eb4bcef9eee150e42821d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void QF::poolInit </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>poolSto</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="qep__port_8h.html#a06896e8c53f721507066c079052171f8">uint32_t</a>&#160;</td>
          <td class="paramname"><em>poolSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QEventSize&#160;</td>
          <td class="paramname"><em>evtSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Event pool initialization for dynamic allocation of events. </p>
<p>This function initializes one event pool at a time and must be called exactly once for each event pool before the pool can be used. The arguments are as follows: <em>poolSto</em> is a pointer to the memory block for the events. <em>poolSize</em> is the size of the memory block in bytes. <em>evtSize</em> is the block-size of the pool in bytes, which determines the maximum size of events that can be allocated from the pool.</p>
<p>You might initialize one, two, and up to three event pools by making one, two, or three calls to the QF_poolInit() function. However, for the simplicity of the internal implementation, you must initialize event pools in the ascending order of the event size.</p>
<p>Many RTOSes provide fixed block-size heaps, a.k.a. memory pools that can be used for <a class="el" href="class_q_f.html" title="QF services. ">QF</a> event pools. In case such support is missing, <a class="el" href="class_q_f.html" title="QF services. ">QF</a> provides a native <a class="el" href="class_q_f.html" title="QF services. ">QF</a> event pool implementation. The macro <a class="el" href="qk_8h.html#ab786be96ee118929bfb4dcd51d3acce5" title="This macro defines the type of the event pool used in this QF port. ">QF_EPOOL_TYPE_</a> determines the type of event pool used by a particular <a class="el" href="class_q_f.html" title="QF services. ">QF</a> port. See class <a class="el" href="class_q_m_pool.html" title="Native QF memory pool class. ">QMPool</a> for more information.</p>
<dl class="section note"><dt>Note</dt><dd>The actual number of events available in the pool might be actually less than (<em>poolSize</em> / <em>evtSize</em>) due to the internal alignment of the blocks that the pool might perform. You can always check the capacity of the pool by calling <a class="el" href="class_q_f.html#a7b72df3c92fc6ead554963443762ca22" title="This function returns the margin of the given event pool. ">QF::getPoolMargin()</a>.</dd>
<dd>
The dynamic allocation of events is optional, meaning that you might choose not to use dynamic events. In that case calling <a class="el" href="class_q_f.html#a5defbf03f35eb4bcef9eee150e42821d" title="Event pool initialization for dynamic allocation of events. ">QF::poolInit()</a> and using up memory for the memory blocks is unnecessary.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_q_f.html" title="QF services. ">QF</a> initialization example for <a class="el" href="class_q_f.html#a6ad3fc234e46c8a32ea9458533db229b" title="QF initialization. ">QF::init()</a> </dd></dl>

<p>Definition at line <a class="el" href="qf__pool_8cpp_source.html#l00047">47</a> of file <a class="el" href="qf__pool_8cpp_source.html">qf_pool.cpp</a>.</p>

<p>References <a class="el" href="qevent_8h_source.html#l00152">Q_DIM</a>, <a class="el" href="qassert_8h_source.html#l00171">Q_REQUIRE</a>, <a class="el" href="qk_8h_source.html#l00166">QF_EPOOL_EVENT_SIZE_</a>, and <a class="el" href="qk_8h_source.html#l00157">QF_EPOOL_INIT_</a>.</p>

</div>
</div>
<a class="anchor" id="a3ce01adc2cf6db212a036306ee03bd33"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void QF::psInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_q_subscr_list.html">QSubscrList</a> *&#160;</td>
          <td class="paramname"><em>subscrSto</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="qevent_8h.html#af55248e13cdc5784f0824c7615c41b7d">QSignal</a>&#160;</td>
          <td class="paramname"><em>maxSignal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish-subscribe initialization. </p>
<p>This function initializes the publish-subscribe facilities of <a class="el" href="class_q_f.html" title="QF services. ">QF</a> and must be called exactly once before any subscriptions/publications occur in the application. The arguments are as follows: <em>subscrSto</em> is a pointer to the array of subscriber-lists. <em>maxSignal</em> is the dimension of this array and at the same time the maximum signal that can be published or subscribed.</p>
<p>The array of subscriber-lists is indexed by signals and provides mapping between the signals and subscirber-lists. The subscriber- lists are bitmasks of type <a class="el" href="class_q_subscr_list.html" title="Subscriber List class. ">QSubscrList</a>, each bit in the bitmask corresponding to the unique priority of an active object. The size of the <a class="el" href="class_q_subscr_list.html" title="Subscriber List class. ">QSubscrList</a> bitmask depends on the value of the <a class="el" href="qf__port_8h.html#a776d2a032974db4bf9bcfde01ace1389" title="The maximum number of active objects in the application. ">QF_MAX_ACTIVE</a> macro.</p>
<dl class="section note"><dt>Note</dt><dd>The publish-subscribe facilities are optional, meaning that you might choose not to use publish-subscribe. In that case calling <a class="el" href="class_q_f.html#a3ce01adc2cf6db212a036306ee03bd33" title="Publish-subscribe initialization. ">QF::psInit()</a> and using up memory for the subscriber-lists is unnecessary.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_q_subscr_list.html" title="Subscriber List class. ">QSubscrList</a></dd></dl>
<p>The following example shows the typical initialization sequence of <a class="el" href="class_q_f.html" title="QF services. ">QF</a>: </p>
<div class="fragment"><div class="line"><span class="comment">// allocate storage for active objects, event queues, event pools,</span></div>
<div class="line"><span class="comment">// subscriber lists, and stacks.</span></div>
<div class="line"><span class="keyword">static</span> <a class="code" href="struct_q_event.html">QEvent</a> <span class="keyword">const</span> *l_tableQueueSto[N_PHILO];</div>
<div class="line"><span class="keyword">static</span> <a class="code" href="struct_q_event.html">QEvent</a> <span class="keyword">const</span> *l_philoQueueSto[N_PHILO][N_PHILO];</div>
<div class="line"><span class="keyword">static</span> <a class="code" href="class_q_subscr_list.html">QSubscrList</a>   l_subscrSto[MAX_PUB_SIG];</div>
<div class="line"></div>
<div class="line"><span class="keyword">static</span> <span class="keyword">union </span>SmallEvents {</div>
<div class="line">    <span class="keywordtype">void</span> *min_size;</div>
<div class="line">    TableEvt te;</div>
<div class="line">    <span class="comment">// other event types to go into this pool</span></div>
<div class="line">} l_smlPoolSto[2*N_PHILO];                 <span class="comment">// storage for the small event pool</span></div>
<div class="line"></div>
<div class="line"><span class="comment">//............................................................................</span></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[]) {</div>
<div class="line"></div>
<div class="line">    BSP_init(argc, argv);                               <span class="comment">// initialize the BSP</span></div>
<div class="line"></div>
<div class="line">    <a class="code" href="class_q_f.html#a6ad3fc234e46c8a32ea9458533db229b">QF::init</a>();       <span class="comment">// initialize the framework and the underlying RT kernel</span></div>
<div class="line"></div>
<div class="line">    <a class="code" href="class_q_f.html#a3ce01adc2cf6db212a036306ee03bd33">QF::psInit</a>(l_subscrSto, <a class="code" href="qevent_8h.html#ad58d2c6dc25f8f0f764eb69faa79eee2">Q_DIM</a>(l_subscrSto));     <span class="comment">// init publish-subscribe</span></div>
<div class="line"></div>
<div class="line">                                                  <span class="comment">// initialize event pools...</span></div>
<div class="line">    <a class="code" href="class_q_f.html#a5defbf03f35eb4bcef9eee150e42821d">QF::poolInit</a>(l_smlPoolSto, <span class="keyword">sizeof</span>(l_smlPoolSto), <span class="keyword">sizeof</span>(l_smlPoolSto[0]));</div>
<div class="line"></div>
<div class="line">                                                <span class="comment">// start the active objects...</span></div>
<div class="line">    <a class="code" href="qep__port_8h.html#a1add8b7f40b8c78daa5d7a2eb886c924">uint8_t</a> n;</div>
<div class="line">    <span class="keywordflow">for</span> (n = 0; n &lt; N_PHILO; ++n) {</div>
<div class="line">        AO_Philo[n]-&gt;start((<a class="code" href="qep__port_8h.html#a1add8b7f40b8c78daa5d7a2eb886c924">uint8_t</a>)(n + 1),</div>
<div class="line">                           l_philoQueueSto[n], <a class="code" href="qevent_8h.html#ad58d2c6dc25f8f0f764eb69faa79eee2">Q_DIM</a>(l_philoQueueSto[n]),</div>
<div class="line">                           (<span class="keywordtype">void</span> *)0, 0, (<a class="code" href="struct_q_event.html">QEvent</a> *)0);</div>
<div class="line">    }</div>
<div class="line">    AO_Table-&gt;<a class="code" href="class_q_active.html#aedb01d8ba6b6de77c8b72df057abe336">start</a>((<a class="code" href="qep__port_8h.html#a1add8b7f40b8c78daa5d7a2eb886c924">uint8_t</a>)(N_PHILO + 1),</div>
<div class="line">                    l_tableQueueSto, <a class="code" href="qevent_8h.html#ad58d2c6dc25f8f0f764eb69faa79eee2">Q_DIM</a>(l_tableQueueSto),</div>
<div class="line">                    (<span class="keywordtype">void</span> *)0, 0, (<a class="code" href="struct_q_event.html">QEvent</a> *)0);</div>
<div class="line"></div>
<div class="line">    <a class="code" href="class_q_f.html#a09b2df3e8eb5f22cd401cd637c40f369">QF::run</a>();                                       <span class="comment">// run the QF application</span></div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="qf__psini_8cpp_source.html#l00044">44</a> of file <a class="el" href="qf__psini_8cpp_source.html">qf_psini.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a65c4972ea4b86162d51fc5ca802fb7bc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void QF::publish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_q_event.html">QEvent</a> const *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>sender</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publish event to the framework. </p>
<p>This function posts (using the FIFO policy) the event <em>e</em> it to ALL active object that have subscribed to the signal <em>e-&gt;sig</em>. This function is designed to be callable from any part of the system, including ISRs, device drivers, and active objects.</p>
<p>In the general case, event publishing requires multi-casting the event to multiple subscribers. This happens in the caller's thread with the scheduler locked to prevent preemptions during the multi- casting process. (Please note that the interrupts are not locked.) </p>

<p>Definition at line <a class="el" href="qf__pspub_8cpp_source.html#l00045">45</a> of file <a class="el" href="qf__pspub_8cpp_source.html">qf_pspub.cpp</a>.</p>

<p>References <a class="el" href="qf__pkg_8h_source.html#l00100">EVT_INC_REF_CTR</a>, <a class="el" href="qf__pkg_8h_source.html#l00094">EVT_POOL_ID</a>, <a class="el" href="qf__pkg_8h_source.html#l00097">EVT_REF_CTR</a>, <a class="el" href="qassert_8h_source.html#l00101">Q_ASSERT</a>, <a class="el" href="qevent_8h_source.html#l00152">Q_DIM</a>, <a class="el" href="qassert_8h_source.html#l00171">Q_REQUIRE</a>, <a class="el" href="qevent_8h_source.html#l00095">Q_ROM_BYTE</a>, <a class="el" href="qf__pwr2_8cpp_source.html#l00051">QF_invPwr2Lkup</a>, <a class="el" href="qf__log2_8cpp_source.html#l00039">QF_log2Lkup</a>, <a class="el" href="qs_8h_source.html#l00711">QS_BEGIN_NOCRIT_</a>, <a class="el" href="qs_8h_source.html#l00722">QS_END_NOCRIT_</a>, <a class="el" href="qs_8h_source.html#l00750">QS_OBJ_</a>, <a class="el" href="qs_8h_source.html#l00083">QS_QF_PUBLISH</a>, <a class="el" href="qs_8h_source.html#l00169">QS_TIME_</a>, <a class="el" href="qs_8h_source.html#l00727">QS_U8_</a>, and <a class="el" href="qevent_8h_source.html#l00140">QEvent::sig</a>.</p>

</div>
</div>
<a class="anchor" id="a0032e774fcf6293d2136e960fcc48528"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void QF::remove_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_q_active.html">QActive</a> const *&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the active object from the framework. </p>
<p>This function should not be called by the application directly, only inside the <a class="el" href="class_q_f.html" title="QF services. ">QF</a> port. The priority level occupied by the active object is freed-up and can be reused for another active object.</p>
<p>The active object that is removed from the framework can no longer participate in the publish-subscribe event exchange.</p>
<dl class="section note"><dt>Note</dt><dd>This function raises an assertion if the priority of the active object exceeds the maximum value <a class="el" href="qf__port_8h.html#a776d2a032974db4bf9bcfde01ace1389" title="The maximum number of active objects in the application. ">QF_MAX_ACTIVE</a> or is not used. </dd></dl>

<p>Definition at line <a class="el" href="qf__act_8cpp_source.html#l00081">81</a> of file <a class="el" href="qf__act_8cpp_source.html">qf_act.cpp</a>.</p>

<p>References <a class="el" href="qs_8h_source.html#l00441">QS::aoObj_</a>, <a class="el" href="qassert_8h_source.html#l00171">Q_REQUIRE</a>, <a class="el" href="qs_8h_source.html#l00711">QS_BEGIN_NOCRIT_</a>, <a class="el" href="qs_8h_source.html#l00722">QS_END_NOCRIT_</a>, <a class="el" href="qs_8h_source.html#l00750">QS_OBJ_</a>, <a class="el" href="qs_8h_source.html#l00068">QS_QF_ACTIVE_REMOVE</a>, <a class="el" href="qs_8h_source.html#l00169">QS_TIME_</a>, and <a class="el" href="qs_8h_source.html#l00727">QS_U8_</a>.</p>

<p>Referenced by <a class="el" href="qvanilla_8cpp_source.html#l00107">QActive::stop()</a>.</p>

</div>
</div>
<a class="anchor" id="a09b2df3e8eb5f22cd401cd637c40f369"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void QF::run </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfers control to <a class="el" href="class_q_f.html" title="QF services. ">QF</a> to run the application. </p>
<p><a class="el" href="class_q_f.html#a09b2df3e8eb5f22cd401cd637c40f369" title="Transfers control to QF to run the application. ">QF::run()</a> is typically called from your startup code after you initialize the <a class="el" href="class_q_f.html" title="QF services. ">QF</a> and start at least one active object with <a class="el" href="class_q_active.html#aedb01d8ba6b6de77c8b72df057abe336" title="Starts execution of an active object and registers the object with the framework. ...">QActive::start()</a>. Also, QF::start() call must precede the transfer of control to <a class="el" href="class_q_f.html#a09b2df3e8eb5f22cd401cd637c40f369" title="Transfers control to QF to run the application. ">QF::run()</a>, but some <a class="el" href="class_q_f.html" title="QF services. ">QF</a> ports might call QF::start() from <a class="el" href="class_q_f.html#a09b2df3e8eb5f22cd401cd637c40f369" title="Transfers control to QF to run the application. ">QF::run()</a>. <a class="el" href="class_q_f.html#a09b2df3e8eb5f22cd401cd637c40f369" title="Transfers control to QF to run the application. ">QF::run()</a> typically never returns to the caller.</p>
<dl class="section note"><dt>Note</dt><dd>This function is strongly platform-dependent and is not implemented in the <a class="el" href="class_q_f.html" title="QF services. ">QF</a>, but either in the <a class="el" href="class_q_f.html" title="QF services. ">QF</a> port or in the Board Support Package (BSP) for the given application. All <a class="el" href="class_q_f.html" title="QF services. ">QF</a> ports must implement <a class="el" href="class_q_f.html#a09b2df3e8eb5f22cd401cd637c40f369" title="Transfers control to QF to run the application. ">QF::run()</a>.</dd>
<dd>
When the Quantum Kernel (<a class="el" href="class_q_k.html" title="QK services. ">QK</a>) is used as the underlying real-time kernel for the <a class="el" href="class_q_f.html" title="QF services. ">QF</a>, all platfrom dependencies are handled in the <a class="el" href="class_q_k.html" title="QK services. ">QK</a>, so no porting of <a class="el" href="class_q_f.html" title="QF services. ">QF</a> is necessary. In other words, you only need to recompile the <a class="el" href="class_q_f.html" title="QF services. ">QF</a> platform-independent code with the compiler for your platform, but you don't need to provide any platform-specific implementation (so, no qf_port.cpp file is necessary). Moreover, <a class="el" href="class_q_k.html" title="QK services. ">QK</a> implements the function <a class="el" href="class_q_f.html#a09b2df3e8eb5f22cd401cd637c40f369" title="Transfers control to QF to run the application. ">QF::run()</a> in a platform-independent way, in the modile <a class="el" href="qk_8cpp.html" title="QK_readySet_, QK_currPrio_, and QK_intNest_ definitions and QK::getVersion(), QK_schedPrio_(), QF::init(), QF::run(), QF::stop(), QActive::start(), QActive::stop() implementations. ">qk.cpp</a>. </dd></dl>

<p>Definition at line <a class="el" href="qvanilla_8cpp_source.html#l00070">70</a> of file <a class="el" href="qvanilla_8cpp_source.html">qvanilla.cpp</a>.</p>

<p>References <a class="el" href="qpset_8h_source.html#l00161">QPSet64::findMax()</a>, <a class="el" href="qa__get___8cpp_source.html#l00045">QActive::get_()</a>, <a class="el" href="qpset_8h_source.html#l00071">QPSet8::notEmpty()</a>, <a class="el" href="class_q_f.html#a27e969500c797c2939cf8bec05273be2">onStartup()</a>, <a class="el" href="qvanilla_8h_source.html#l00072">QF_currPrio_</a>, and <a class="el" href="qvanilla_8h_source.html#l00065">QF_readySet_</a>.</p>

<p>Referenced by <a class="el" href="lint__qk__4_81_807_8txt_source.html#l00021">QK::getVersion()</a>.</p>

</div>
</div>
<a class="anchor" id="a1a8e5a6ad959cd7cf52eed88cbdad20c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void QF::stop </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function invoked by the application layer to stop the <a class="el" href="class_q_f.html" title="QF services. ">QF</a> application and return control to the OS/Kernel. </p>
<p>This function stops the <a class="el" href="class_q_f.html" title="QF services. ">QF</a> application. After calling this function, <a class="el" href="class_q_f.html" title="QF services. ">QF</a> attempts to gracefully stop the application. This graceful shutdown might take some time to complete. The typical use of this funcition is for terminating the <a class="el" href="class_q_f.html" title="QF services. ">QF</a> application to return back to the operating system or for handling fatal errors that require shutting down (and possibly re-setting) the system.</p>
<p>This function is strongly platform-specific and is not implemented in the <a class="el" href="class_q_f.html" title="QF services. ">QF</a> but either in the <a class="el" href="class_q_f.html" title="QF services. ">QF</a> port or in the Board Support Package (BSP) for the given application. Some <a class="el" href="class_q_f.html" title="QF services. ">QF</a> ports might not require implementing <a class="el" href="class_q_f.html#a1a8e5a6ad959cd7cf52eed88cbdad20c" title="Function invoked by the application layer to stop the QF application and return control to the OS/Ker...">QF::stop()</a> at all, because many embedded application don't have anything to exit to.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_q_f.html#a1a8e5a6ad959cd7cf52eed88cbdad20c" title="Function invoked by the application layer to stop the QF application and return control to the OS/Ker...">QF::stop()</a> and <a class="el" href="class_q_f.html#a9569a5e1a10e536650109855cd89af47" title="Cleanup QF callback. ">QF::onCleanup()</a> </dd></dl>

<p>Definition at line <a class="el" href="qvanilla_8cpp_source.html#l00065">65</a> of file <a class="el" href="qvanilla_8cpp_source.html">qvanilla.cpp</a>.</p>

<p>References <a class="el" href="class_q_f.html#a9569a5e1a10e536650109855cd89af47">onCleanup()</a>.</p>

<p>Referenced by <a class="el" href="lint__qk__4_81_807_8txt_source.html#l00021">QK::getVersion()</a>.</p>

</div>
</div>
<a class="anchor" id="aee589dbe41a722dd412826c6a8b69c2e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void QF::tick </td>
          <td>(</td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>sender</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Processes all armed time events at every clock tick. </p>
<p>This function must be called periodically from a time-tick ISR or from the highest-priority task so that <a class="el" href="class_q_f.html" title="QF services. ">QF</a> can manage the timeout events.</p>
<dl class="section note"><dt>Note</dt><dd>The <a class="el" href="class_q_f.html#aee589dbe41a722dd412826c6a8b69c2e" title="Processes all armed time events at every clock tick. ">QF::tick()</a> function is not reentrant meaning that it must run to completion before it is called again. Also, <a class="el" href="class_q_f.html#aee589dbe41a722dd412826c6a8b69c2e" title="Processes all armed time events at every clock tick. ">QF::tick()</a> assumes that it never will get preempted by a task, which is always the case when it is called from an ISR or the highest-priority task.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_q_time_evt.html" title="Time Event class. ">QTimeEvt</a>.</dd></dl>
<p>The following example illustrates the call to <a class="el" href="class_q_f.html#aee589dbe41a722dd412826c6a8b69c2e" title="Processes all armed time events at every clock tick. ">QF::tick()</a>: </p>
<div class="fragment"><div class="line"><span class="comment">// case 1: Interrupt Controller available,</span></div>
<div class="line"><span class="comment">// &quot;unconditional interrupt unlocking&quot; critical section policy</span></div>
<div class="line"><span class="comment">// (nesting of critical sections _not_ allowed)</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">interrupt <span class="keywordtype">void</span> ISR_timer() {     <span class="comment">// entered with interrupts locked in hardware</span></div>
<div class="line">    <a class="code" href="qf__port_8h.html#a2f54624c77da2ce84f7666bd0695f186">QF_INT_UNLOCK</a>(dummy);                                 <span class="comment">// unlock interrupts</span></div>
<div class="line"></div>
<div class="line">    <a class="code" href="class_q_f.html#aee589dbe41a722dd412826c6a8b69c2e">QF::tick</a>();                              <span class="comment">//&lt;-- call the QF tick processing</span></div>
<div class="line"></div>
<div class="line">    <a class="code" href="qf__port_8h.html#aecafaa15f9f2d55cc0557f8b4c951098">QF_INT_LOCK</a>(dummy);                               <span class="comment">// lock interrupts again</span></div>
<div class="line">    <span class="comment">// send the EOI instruction to the Interrupt Controller</span></div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// case 2: Interrupt Controller not used,</span></div>
<div class="line"><span class="comment">// &quot;saving and restoring interrupt status&quot; critical section policy</span></div>
<div class="line"><span class="comment">// (nesting of critical sections allowed)</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">interrupt <span class="keywordtype">void</span> ISR_timer() {</div>
<div class="line">    <a class="code" href="class_q_f.html#aee589dbe41a722dd412826c6a8b69c2e">QF::tick</a>();                              <span class="comment">//&lt;-- call the QF tick processing</span></div>
<div class="line">}</div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="qf__tick_8cpp_source.html#l00044">44</a> of file <a class="el" href="qf__tick_8cpp_source.html">qf_tick.cpp</a>.</p>

<p>References <a class="el" href="qs_8h_source.html#l00711">QS_BEGIN_NOCRIT_</a>, <a class="el" href="qs_8h_source.html#l00722">QS_END_NOCRIT_</a>, <a class="el" href="qs_8h_source.html#l00750">QS_OBJ_</a>, <a class="el" href="qs_8h_source.html#l00088">QS_QF_TICK</a>, <a class="el" href="qs_8h_source.html#l00090">QS_QF_TIMEEVT_AUTO_DISARM</a>, <a class="el" href="qs_8h_source.html#l00094">QS_QF_TIMEEVT_POST</a>, <a class="el" href="qs_8h_source.html#l00169">QS_TIME_</a>, <a class="el" href="qevent_8h_source.html#l00140">QEvent::sig</a>, <a class="el" href="qs_8h_source.html#l00444">QS::teObj_</a>, and <a class="el" href="qs_8h_source.html#l00450">QS::tickCtr_</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a82e692a5232ab9f5226168f345a2af11"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_q_active.html">QActive</a> * QF::active_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>array of registered active objects </p>
<dl class="section note"><dt>Note</dt><dd>Not to be used by Clients directly, only in ports of <a class="el" href="class_q_f.html" title="QF services. ">QF</a> </dd></dl>

<p>Definition at line <a class="el" href="qf_8h_source.html#l00924">924</a> of file <a class="el" href="qf_8h_source.html">qf.h</a>.</p>

<p>Referenced by <a class="el" href="qk__sched_8cpp_source.html#l00051">QK_sched_()</a>, <a class="el" href="qk__ext_8cpp_source.html#l00051">QK_schedExt_()</a>, <a class="el" href="qa__sub_8cpp_source.html#l00042">QActive::subscribe()</a>, <a class="el" href="qa__usub_8cpp_source.html#l00042">QActive::unsubscribe()</a>, and <a class="el" href="qa__usuba_8cpp_source.html#l00042">QActive::unsubscribeAll()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="qf_8h_source.html">qf.h</a></li>
<li><a class="el" href="qa__get___8cpp_source.html">qa_get_.cpp</a></li>
<li><a class="el" href="qf__act_8cpp_source.html">qf_act.cpp</a></li>
<li><a class="el" href="qf__gc_8cpp_source.html">qf_gc.cpp</a></li>
<li><a class="el" href="qf__new_8cpp_source.html">qf_new.cpp</a></li>
<li><a class="el" href="qf__pool_8cpp_source.html">qf_pool.cpp</a></li>
<li><a class="el" href="qf__psini_8cpp_source.html">qf_psini.cpp</a></li>
<li><a class="el" href="qf__pspub_8cpp_source.html">qf_pspub.cpp</a></li>
<li><a class="el" href="qf__tick_8cpp_source.html">qf_tick.cpp</a></li>
<li><a class="el" href="qmp__get_8cpp_source.html">qmp_get.cpp</a></li>
<li><a class="el" href="qvanilla_8cpp_source.html">qvanilla.cpp</a></li>
<li><a class="el" href="qk_8cpp_source.html">qk.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Nov 28 2016 21:26:18 for QP/C++ by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
